import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import ProgressionSystem from '../../../src/modules/ProgressionSystem.js';
import RandomService from '../../../src/core/RandomService.js';
import { createEventBusMock } from '../../__helpers__/mocks.js';
import {
  setupGlobalMocks,
  cleanupGlobalState,
  createTestContainer,
} from '../../__helpers__/setup.js';

const noop = () => {};

/**
 * Collect upgrade identifiers generated by the provided progression system.
 *
 * @param {ProgressionSystem} progression - Progression system under test.
 * @param {number} count - Number of upgrade options requested.
 * @returns {string[]} Ordered list of upgrade identifiers generated by the system.
 */
function collectUpgradeIds(progression, count) {
  const { options } = progression.prepareUpgradeOptions(count);

  return options
    .map((option) => option?.id)
    .filter(Boolean);
}

describe('ProgressionSystem determinism', () => {
  beforeEach(() => {
    setupGlobalMocks({ gameEvents: createEventBusMock() });
  });

  afterEach(() => {
    cleanupGlobalState();
  });

  // Note: vi.restoreAllMocks() handled by global setup (tests/__helpers__/global-setup.js)

  describe('with ServiceRegistry container', () => {
    // Ensures RandomService reset restores the exact upgrade sequence.
    it('produces identical upgrade options after RandomService reset', () => {
      const container = createTestContainer('424242');
      const random = container.resolve('random');
      const progression = new ProgressionSystem({
        random,
        player: {},
        ui: {},
        effects: {},
        'xp-orbs': {
          attachProgression: noop,
        },
      });

      const initialOptions = collectUpgradeIds(progression, 5);
      expect(initialOptions).toHaveLength(5);

      collectUpgradeIds(progression, 5);

      random.reset(random.seed);
      globalThis.gameEvents.emit('progression-reset');
      globalThis.gameEvents.emit('player-reset');

      const postResetOptions = collectUpgradeIds(progression, 5);

      expect(postResetOptions).toStrictEqual(initialOptions);
    });
  });

  describe('with direct RandomService instantiation', () => {
    const createProgression = (seed) =>
      new ProgressionSystem({
        random: new RandomService(seed),
        player: {},
        ui: {},
        effects: {},
        'xp-orbs': {
          attachProgression: noop,
        },
      });

    // Validates that reset events alone replay the deterministic sequence.
    it('produces identical upgrade options after event-based resets', () => {
      const progression = createProgression(424242);

      const firstRun = collectUpgradeIds(progression, 5);
      expect(firstRun).toHaveLength(5);

      globalThis.gameEvents.emit('progression-reset');
      const secondRun = collectUpgradeIds(progression, 5);
      expect(secondRun).toStrictEqual(firstRun);

      globalThis.gameEvents.emit('player-reset');
      const thirdRun = collectUpgradeIds(progression, 5);

      expect(thirdRun).toStrictEqual(firstRun);
    });

    // Confirms separate instances seeded equally stay in sync.
    it('matches upgrade options for separate instances with the same seed', () => {
      const first = createProgression(1337);
      const second = createProgression(1337);

      const firstOptions = collectUpgradeIds(first, 4);
      const secondOptions = collectUpgradeIds(second, 4);

      expect(firstOptions).toStrictEqual(secondOptions);
    });
  });
});
