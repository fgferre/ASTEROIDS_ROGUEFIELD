# Plano de Execução – Fase 3 (GameSessionService e isolamento do estado da sessão)

## 1. Objetivos da fase
- Consolidar todo o ciclo de sessão (start, pause, morte, retry, quit) em um `GameSessionService` registrado via manifesto/DI, removendo orquestração direta de `app.js` e mantendo o loop principal focado apenas em bootstrap/render.【F:src/app.js†L20-L33】【F:src/app.js†L880-L1072】
- Centralizar snapshots, restauração e resets de sistemas no novo serviço, garantindo coordenação com o RNG seedado e com os serviços de gameplay/UI já existentes.【F:src/app.js†L204-L249】【F:src/app.js†L386-L682】
- Preservar compatibilidade com módulos que consultam `game-state` e eventos globais (`UISystem`, `AudioSystem`, etc.), expondo uma API explícita para estado da run, seeds atuais e ponte com o DOM enquanto `UISystem` assume a UI interativa.【F:src/bootstrap/serviceManifest.js†L35-L55】【F:src/modules/UISystem.js†L994-L1060】【F:src/modules/AudioSystem.js†L181-L235】

## 2. Diagnóstico atual (evidências)
1. `app.js` acumula responsabilidades de estado global (`gameState`), resets em lote, controle de tela e persistência de seed, misturando infraestrutura com regras de sessão.【F:src/app.js†L20-L33】【F:src/app.js†L386-L427】【F:src/app.js†L703-L738】
2. Fluxos de morte/retry manipulam serviços e DOM diretamente (`createDeathSnapshot`, `executeRetryRespawn`, countdown), dificultando reutilização ou testes isolados.【F:src/app.js†L440-L682】
3. Listeners de DOM e eventos globais vivem em `app.js`, acionando funções internas ao invés de uma API dedicada; isso impede reutilizar o fluxo para outros inputs (ex.: comandos remotos).【F:src/app.js†L764-L867】
4. O manifesto disponibiliza um serviço `game-state` mínimo (get/set) que não acompanha seeds, snapshots ou timers da sessão, deixando consumidores cegos quanto ao status real da run.【F:src/bootstrap/serviceManifest.js†L35-L55】
5. Sistemas de gameplay já oferecem `reset`/`respawn` mas esperam coordenação externa: Player, Progression, Enemy, Physics, XP Orbs, Health Hearts e World carecem de um orquestrador que chame reset, restaure stats ou reconfigure caches no momento certo.【F:src/modules/PlayerSystem.js†L954-L998】【F:src/modules/ProgressionSystem.js†L1079-L1094】【F:src/modules/EnemySystem.js†L1599-L1614】【F:src/modules/PhysicsSystem.js†L694-L717】【F:src/modules/XPOrbSystem.js†L2002-L2027】【F:src/modules/collectibles/HealthHeartSystem.js†L107-L112】【F:src/modules/WorldSystem.js†L145-L189】
6. O fluxo de start/quit e o game loop dependem de `gameState.screen/isPaused`; se movermos o estado sem atualizar quem consulta (loop, UI, áudio), veremos frames processados quando não deveria ou menus inconsistentes.【F:src/app.js†L880-L1072】【F:src/modules/UISystem.js†L2842-L2855】【F:src/modules/AudioSystem.js†L181-L235】
7. Snapshots assumem APIs opcionais (`progression.restoreState`, `enemies.getSnapshotState`, `physics.restoreSnapshotState`) que hoje retornam `undefined` por falta de implementação; o novo serviço precisa padronizar fallback ou fornecer implementações baseadas em `serialize/deserialize`.【F:src/app.js†L471-L527】【F:src/modules/EnemySystem.js†L742-L808】【F:src/modules/ProgressionSystem.js†L1098-L1119】

## 3. Estratégia geral
- Introduzir `GameSessionService` como serviço singleton não lazy, recebendo via injeção o event bus, RNG, UI, Player, Progression, Enemy, Physics, XP Orbs, HealthHearts, World e Audio; manter acesso ao `manifestContext.gameState` apenas como storage legado/compatibilidade.
- Migrar gradualmente funções de `app.js` (seed scoping, resets, start/exit, snapshot, retry, listeners) para o serviço, expondo métodos públicos (`initialize`, `startNewRun`, `handlePlayerDeath`, `requestRetry`, `exitToMenu`, `togglePause`) e emitindo eventos padronizados.
- Atualizar `createServiceManifest`/`ServiceRegistry` para registrar o novo serviço e adaptar `game-state` para ser um facade sobre `GameSessionService` (delegando getters/setters e expondo seed/timestamp) mantendo `gameServices.register` ativo para legado.
- Deixar `app.js` responsável só por bootstrap DI, criação do canvas/loop e pela injeção do serviço (resolvendo-o após o bootstrap para chamar `initialize`), mantendo `performanceMonitor`, guardião de `Math.random()` e o `requestAnimationFrame`.

## 4. Sequenciamento detalhado
| Ordem | Passo | Descrição | Pré-requisito | Critério de aceite |
|-------|-------|-----------|---------------|--------------------|
| 1 | Mapear dependências | Inventariar todos os pontos de acesso que o serviço precisará (RNG, UI, Player, Progression, Enemy, Physics, XP Orbs, HealthHearts, World, Audio, DOM IDs) e documentar contratos esperados (reset, serialize, etc.). | — | Documento interno/trechos comentados no PR descrevendo dependências e fallback planejado. |
| 2 | Registrar `GameSessionService` | Criar o arquivo do serviço, registrá-lo no manifesto/ServiceRegistry com dependências corretas e sincronizar com `gameServices`/adapter para consumo legado. Ajustar `game-state` para delegar ao serviço. | Passo 1 | `diContainer.resolve('game-session')` retorna instância funcional; `gameServices.get('game-session')` funciona. |
| 3 | Migrar gerenciamento de seed/snapshots | Mover `prepareRandomForScope`, `logRandomSnapshot`, sincronização com áudio e persistência de seed para o serviço, expondo métodos utilitários e armazenando último snapshot; ajustar `app.js` para usar a API nova. | Passo 2 | Logs de seed continuam aparecendo e retry/start mantêm determinismo. |
| 4 | Migrar resets/snapshot de sistemas | Transferir `resetGameSystems`, `createDeathSnapshot`, `restoreFromSnapshot`, `findSafeSpawnPoint` para o serviço; implementar/ajustar serialização mínima em Progression/Enemies/Physics quando inexistente, garantindo fallback seguro. | Passo 3 | Retry restaura estado visível (XP, upgrades, asteroides) sem regressões; testes manuais confirmam. |
| 5 | Mover ciclo de run (start/exit/retry) | Implementar métodos `startNewRun`, `exitToMenu`, `performExit`, `beginRetryCountdown`, `completeRetryRespawn` dentro do serviço e atualizar `app.js`/listeners para chamá-los. | Passo 4 | Botões de menu/retry continuam funcionando; logs antigos aparecem uma única vez. |
| 6 | Centralizar listeners e timers | Relocar `setupDomEventListeners`, `setupGlobalEventListeners` e o controle de pause para o serviço, garantindo reemissão de `pause-state-changed` e uso do event bus. | Passo 5 | `toggle-pause`, `exit-to-menu-requested` e `player-died` disparam o serviço, com UI/áudio respondendo normalmente. |
| 7 | Higienizar `app.js` | Remover responsabilidades migradas, deixar `init()` focado em bootstrap, resolução do serviço e início do loop; garantir que `gameLoop` consulte estado via serviço (direto ou via `gameState`). | Passo 6 | `app.js` fica restrito a ~bootstrap/loop; cobertura manual confirma ausência de regressões. |
| 8 | Instrumentação e testes | Atualizar `ServiceRegistry.createTestContainer` com stub da sessão, preparar casos de teste manuais (start -> morrer -> retry -> quit) e validar seeds persistidos/localStorage. | Passos 6-7 | Checklist de validação preenchido incluindo fluxo de retry/quit, sem erros no console. |

## 5. Ajustes específicos por componente
- **`app.js`:** Após migrar funções, manter apenas bootstrap, loop, `performanceMonitor` e vínculo com canvas/contexto. Trocar acessos diretos a `gameState` (screen/pause/seed) por chamadas ao serviço ou ao facade `game-state`. O loop deve consultar `gameSession.isRunning()`/`isPaused()` para decidir `updateGame`, preservando resets do monitor.【F:src/app.js†L684-L1072】
- **`GameSessionService` (novo):** Estruturar estado interno com campos equivalentes aos atuais (`screen`, `isPaused`, `deathSnapshot`, `randomSeed`, `randomScope`, timers) e expor métodos idempotentes. Ele deve injetar serviços necessários e manter referências DOM cacheadas para countdown/botões, evitando buscas repetidas. Responsável por: preparar RNG por escopo, resetar serviços em ordem segura, restaurar snapshots, coordenar UI (`ui.showGameUI`, `ui.showScreen`), iniciar áudio e atualizar contadores de retry.【F:src/app.js†L204-L994】【F:src/modules/UISystem.js†L2842-L2855】【F:src/modules/AudioSystem.js†L181-L235】
- **`createServiceManifest`/`ServiceRegistry`:** Adicionar entrada `game-session` (singleton, lazy=false) após registrar dependências base (event bus, random, game-state) e antes dos sistemas que o serviço controla. Atualizar `ensureGameStateService` para delegar a `gameSession` quando disponível, mantendo fallback para `gameState` bruto durante bootstrap.【F:src/bootstrap/serviceManifest.js†L35-L205】
- **Sistemas de gameplay:** Confirmar que cada `reset` limpa estado e dispara eventos (Player, Progression, Enemies, Physics, XP Orbs, HealthHearts, World). Expandir com snapshots quando necessário: usar `ProgressionSystem.serialize()/deserialize` para `restoreState`; criar métodos `EnemySystem.exportState()`/`importState()` baseados em `waveState`/`sessionStats`; em `PhysicsSystem`, capturar/restaurar asteroides via `activeAsteroids` + seeds dos geradores; fornecer fallback caso ainda não implementado (limpeza completa + respawn).【F:src/modules/PlayerSystem.js†L954-L998】【F:src/modules/ProgressionSystem.js†L1079-L1119】【F:src/modules/EnemySystem.js†L742-L1723】【F:src/modules/PhysicsSystem.js†L694-L717】
- **Eventos globais:** `GameSessionService` deve ouvir `player-died`, `toggle-pause`, `exit-to-menu-requested` e outros sinais relevantes, evitando duplicidade com `WorldSystem` (que já emite `player-died`). Ele também deve reemitir `pause-state-changed` e atualizar `screen` via event bus para que UI/Áudio reajam.【F:src/modules/WorldSystem.js†L145-L189】【F:src/modules/UISystem.js†L994-L1060】【F:src/modules/AudioSystem.js†L181-L235】
- **Random/Seeds:** Preservar `persistLastSeed`, snapshots de RNG e sincronização com áudio (`reseedRandomScopes`). O serviço deve armazenar o snapshot atual e expor método `getRandomSnapshot()` para debugging, garantindo que `retry` restaure o mesmo estado ao chamar `random.restore()`.【F:src/app.js†L204-L249】【F:src/app.js†L703-L738】
- **Retry Countdown:** Encapsular criação e limpeza do elemento `#retry-countdown` no serviço, evitando vazamentos. Permitir customização futura (ex.: animação no UI) emitindo evento `session-retry-countdown` ao invés de mexer diretamente no DOM, mantendo fallback atual enquanto a UI não assume. 【F:src/app.js†L586-L682】
- **UI/Áudio integração:** Garantir que `ui.showGameUI()`, `ui.showScreen('menu')`, `ui.resetLevelUpState()` e `audio.init()` sejam acionados via serviço, respeitando ordem (UI antes de liberar input, áudio apenas em runs novas). Ao sair para o menu via pausa, preservar explosão épica controlada pelo serviço (incluindo `_quitExplosionHidden`).【F:src/app.js†L880-L994】【F:src/modules/UISystem.js†L2842-L2855】
- **Testabilidade:** Atualizar `ServiceRegistry.createTestContainer` para permitir injetar stub de `game-session` (com métodos no-op) e seeds fixos. Preparar scripts de smoke test manual cobrindo ciclo completo: start → jogar → morrer → retry → sair. 【F:src/core/ServiceRegistry.js†L30-L118】

## 6. Validação e monitoramento
- **Check manual de ciclo completo:** Start -> coletar XP -> morrer -> aguardar game over -> retry -> confirmar restauração de upgrades/seed -> quit para menu -> iniciar nova run.
- **Logs determinísticos:** Verificar console para snapshots `[Random]` em cada transição (bootstrap, run.start, retry.respawn, menu.exit) garantindo que `GameSessionService` imprima escopos consistentes.【F:src/app.js†L204-L994】
- **PerformanceMonitor:** Confirmar que métricas continuam atualizando apenas quando `screen === 'playing'` e não durante menus/pausa, ajustando consultas ao serviço conforme necessário.【F:src/app.js†L996-L1042】
- **Persistência de seed:** Validar que `persistLastSeed` continua gravando/recuperando localStorage após a migração. 【F:src/app.js†L68-L131】

## 7. Riscos e mitigação
- **APIs de snapshot incompletas:** Como `createDeathSnapshot` depende de métodos opcionais, precisamos implementar serialização real (Progression, Enemies, Physics) ou documentar fallback consistente (reset + respawn determinístico). Mitigar adicionando testes de restauração e logs quando determinado subsistema não oferecer snapshot.【F:src/app.js†L471-L527】【F:src/modules/EnemySystem.js†L742-L808】
- **Desalinhamento com o loop:** Se `gameLoop` continuar lendo `gameState` enquanto o serviço mantém seu próprio estado, podemos atualizar frames durante menus. Mitigar expondo getters no serviço e sincronizando `gameState` legado sempre que `screen`/`isPaused` mudar.【F:src/app.js†L996-L1072】
- **Eventos duplicados ou perdidos:** Ao mover listeners, há risco de emitir `pause-state-changed` múltiplas vezes ou esquecer de cancelar timeouts da explosão épica. Mitigar centralizando timers no serviço e adicionando guardas (`if (this.currentScreen === ...) return`).【F:src/app.js†L915-L994】【F:src/modules/AudioSystem.js†L181-L235】
- **Dependência no DOM direto:** Enquanto UI não absorver o countdown, manipulações diretas do DOM devem ser encapsuladas e limpas no `destroy`. Planejar transição futura emitindo eventos específicos para o `UISystem`.【F:src/app.js†L586-L682】【F:src/modules/UISystem.js†L994-L1060】

## 8. Checklist de saída da Fase 3
- [ ] `GameSessionService` registrado no manifesto e exposto via DI/Service Locator, substituindo funções de sessão em `app.js`.
- [ ] `app.js` reduzido a bootstrap, seed inicial, loop e logs, delegando ciclo de sessão ao serviço.
- [ ] Fluxos de start, pausa, morte, retry e quit operando através do serviço com snapshots/seed restaurados.
- [ ] Facade `game-state` e consumidores (`UISystem`, `AudioSystem`, testes) funcionando com a nova fonte de verdade.
- [ ] Séries de resets e restauradores dos sistemas críticos (Player, Progression, Enemy, Physics, XP Orbs, Health Hearts, World) validadas após retry.
- [ ] Logs e persistência de seed confirmados; checklist de validação (docs/validation) atualizado com cenário de retry/quitting.

## 9. Matriz de contratos da sessão (referência rápida)

### 9.1 Funções de `app.js` que manipulam estado de sessão
| Função | Responsabilidade principal | Serviços/Eventos/DOM utilizados | Observações |
|--------|----------------------------|---------------------------------|-------------|
| `parseSeedCandidate`, `persistLastSeed`, `deriveInitialSeed` | Limpar candidatos de seed, persistir último seed e escolher fonte inicial (URL, localStorage, crypto, Math.random) | `window.localStorage`, `URLSearchParams`, constantes `RANDOM_STORAGE_KEYS` | Mantêm `gameState.randomSeed`/`randomSeedSource`; qualquer serviço futuro deve assumir persistência idempotente. 【F:src/app.js†L50-L131】 |
| `logRandomSnapshot`, `getRandomService`, `synchronizeAudioRandomScopes`, `prepareRandomForScope` | Serializar/restaurar RNG seedado, sincronizar forks de áudio e armazenar snapshot corrente | Serviço `random` (`serialize`, `restore`, `reset`), serviço `audio` (`reseedRandomScopes`/`captureRandomScopes`), `gameState.randomSnapshot/randomScope` | Falha ao serializar restaura via `random.reset`; serviço de sessão deve manter fallback equivalente. 【F:src/app.js†L133-L249】 |
| `initializeDependencyInjection` | Instanciar `DIContainer`, registrar manifesto e espelhar `gameServices` no adaptador | `ServiceRegistry.setupServices`, `ServiceLocatorAdapter`, `performanceMonitor`, `globalThis.gameServices` | Em caso de erro, reverte para locator legado; sessão deve preservar esse fallback. 【F:src/app.js†L299-L383】 |
| `resetGameSystems` | Invocar `reset` em lote sobre sistemas críticos | Serviços `player`, `combat`, `enemies`, `physics`, `progression`, `xp-orbs`, `healthHearts`, `effects`, `renderer`, `world`, `audio` | Ignora serviços ausentes; registra aviso se `reset` falhar. 【F:src/app.js†L386-L427】 |
| `emitPauseState` | Propagar pausa atual | Evento `gameEvents.emit('pause-state-changed')` | Sessão deve continuar emitindo para `UISystem`/`AudioSystem`. 【F:src/app.js†L429-L433】 |
| `createDeathSnapshot` | Consolidar snapshot (player, progression, enemies, physics, RNG) no `gameState` | Serviços `player`, `enemies`, `physics`, `progression`, `random`, `gameState.deathSnapshot` | Depende de métodos opcionais `getSnapshotState`/`serialize`; ausência gera `null` e exige fallback. 【F:src/app.js†L440-L480】 |
| `restoreFromSnapshot` | Restaurar estado após retry | Serviços `player`, `progression`, `enemies`, `physics`, `random`; chama `prepareRandomForScope` | Espera `progression.restoreState`, `enemies.restoreSnapshotState`, `physics.restoreSnapshotState` (não implementados). 【F:src/app.js†L483-L536】 |
| `findSafeSpawnPoint` | Calcular ponto seguro para respawn | Serviço `enemies.getAsteroids()`, `gameState.canvas`, constantes de distância | Sem fallback se lista de asteroides não existir além de centro padrão. 【F:src/app.js†L538-L582】 |
| `startRetryCountdown`, `showCountdownNumber`, `executeRetryRespawn` | Gerenciar DOM de contagem regressiva, restaurar snapshot e respawnar player | DOM `#gameover-screen`, `#retry-countdown`, `#game-ui`, serviços `player`, `world`, RNG | Mantêm flag `player.isRetrying`; limpam DOM manualmente até UI assumir. 【F:src/app.js†L584-L682】 |
| `init` | Bootstrap geral: canvas, listeners, seed inicial, DI, primeira chamada do loop | DOM `#game-canvas`, `document.addEventListener`, `bootstrapServices`, `prepareRandomForScope`, serviço `ui` | Marca `gameState.initialized`; ativa guardião de Math.random em dev. 【F:src/app.js†L684-L758】 |
| `setupDomEventListeners` | Delegar cliques de botões da UI legada | Eventos `document.addEventListener('click')`, DOM IDs `start-game-btn`, `restart-game-btn`, `retry-game-btn`, `quit-game-btn`, `open-settings-btn`, `menu-credits-btn`, `#retry-count` | Até refatoração da UI, sessão precisa manter esses listeners/IDs. 【F:src/app.js†L764-L813】 |
| `setupGlobalEventListeners` | Responder a eventos globais (screen, morte, pause, exit, shield) | `gameEvents.on('screen-changed'/'player-died'/'toggle-pause'/'exit-to-menu-requested'/'activate-shield-pressed')`, serviços `player`, `gameState.screen/isPaused` | Despausa automaticamente quando tela muda; gera snapshot ao receber `player-died`. 【F:src/app.js†L816-L867】 |
| `requestStartGame`, `startGame` | Encerrar overlays, preparar RNG e iniciar nova run | Eventos `credits-menu-requested`, serviços `audio.init`, `ui.showGameUI`, `resetGameSystems`, DOM `#retry-count`, `#retry-game-btn`, `gameState` flags | Define `gameState.screen/isPaused`, reinicializa contadores. 【F:src/app.js†L869-L913】 |
| `exitToMenu`, `performExitToMenu` | Fluxo de saída para o menu, incluindo explosão épica opcional | Serviços `player`, `effects.createEpicShipExplosion`, `ui.showScreen/resetLevelUpState`, `resetGameSystems`, RNG, DOM `#game-ui` | Usa `_quitExplosionHidden` como flag; fallback imediato chama `performExitToMenu`. 【F:src/app.js†L915-L994】 |
| `gameLoop`, `updateGame`, `renderGame` | Loop principal: atualiza pools, sistemas e renderização condicionado a `gameState` | `GamePools.update`, `garbageCollectionManager.update`, serviços `effects`, `input`, `player`, `enemies`, `physics`, `combat`, `xp-orbs`, `healthHearts`, `progression`, `world`, `ui`, `renderer`, `performanceMonitor` | Usa `gameState.screen/isPaused` para gatear atualizações; sessão deverá fornecer getters equivalentes. 【F:src/app.js†L996-L1081】 |

### 9.2 Contratos exigidos dos sistemas dependentes
| Sistema | Métodos/Eventos atualmente necessários | Fallbacks / Lacunas observadas |
|---------|-----------------------------------------|-------------------------------|
| `PlayerSystem` | `reset()` limpa posição/flags; `respawn(position, invulnerability)` reinicia nave; `markDead()` usado pelo `WorldSystem`; `activateShield()` ouvido em `app.js`; propriedades `maxHealth`, `health`, `position`, `upgrades`, `_quitExplosionHidden`, `isRetrying` manipuladas diretamente. 【F:src/modules/PlayerSystem.js†L922-L989】【F:src/app.js†L507-L682】【F:src/app.js†L917-L940】 | Não há API formal para sinalizar retry (`isRetrying` setado diretamente); considerar expor métodos para ocultar nave em explosão. |
| `ProgressionSystem` | `reset()` emite `progression-reset`; métodos de serialização `serialize()`/`deserialize()` disponíveis para snapshot. 【F:src/modules/ProgressionSystem.js†L1078-L1120】 | `app.js` chama `progression.restoreState`, mas método não existe—precisa mapear para `deserialize` ou implementar alias. 【F:src/app.js†L515-L517】 |
| `EnemySystem` | `reset()` recria ondas e notifica; getters `getAsteroids()`, `getWaveState()`, `getSessionStats()` usados para spawn seguro e UI; integrações com eventos `wave-started`/`wave-completed`. 【F:src/modules/EnemySystem.js†L1580-L1660】【F:src/modules/EnemySystem.js†L1549-L1561】【F:src/modules/EnemySystem.js†L1689-L1736】 | `getSnapshotState`/`restoreSnapshotState` esperados em retry não existem—precisa definir contrato real (provável `serialize`/`deserialize`). 【F:src/app.js†L471-L522】 |
| `PhysicsSystem` | `reset()` limpa malha e emite `physics-reset`; fornece consultas para colisões/asteroides usadas indiretamente. 【F:src/modules/PhysicsSystem.js†L694-L717】 | Snapshot ausente (`getSnapshotState`/`restoreSnapshotState` chamados em retry mas não implementados). 【F:src/app.js†L471-L527】 |
| `XPOrbSystem` | `reset()` recompõe pools, reconfigura magnetismo e emite `xp-orbs-reset`; chamado em resets globais. 【F:src/modules/XPOrbSystem.js†L2002-L2027】 | Nenhum mecanismo de snapshot/restauração—retry depende apenas de determinismo do RNG. |
| `collectibles/HealthHeartSystem` | `reset()` limpa corações e cache de jogador. 【F:src/modules/collectibles/HealthHeartSystem.js†L101-L117】 | Sem suporte para snapshots; atualmente suficiente pois corações são reaprovionados pelo fluxo padrão. |
| `WorldSystem` | `handlePlayerDeath()` emite `player-died` com estatísticas para UI; `reset()` revalida serviços; usa `player.markDead()` e dados de inimigos/progressão. 【F:src/modules/WorldSystem.js†L145-L189】 | Sem método dedicado para “prepareRetry”; relya no serviço de sessão para reativar `playerAlive`. |
| `UISystem` | `showScreen()` manipula DOM e emite `screen-changed`; `showGameUI()` e `resetLevelUpState()` usados em start/exit; `updatePauseScreen()` reage a `pause-state-changed`. 【F:src/modules/UISystem.js†L2779-L2855】【F:src/modules/UISystem.js†L3169-L3192】 | Até nova UI, `app.js` precisa continuar chamando métodos diretos e controlando elementos fora do escopo do sistema. |
| `AudioSystem` | `init()` instancia contexto WebAudio; `reseedRandomScopes()`/`captureRandomScopes()` sincronizam RNG com serviço de sessão; ouve `gameEvents` para áudio dinâmico. 【F:src/modules/AudioSystem.js†L69-L107】【F:src/modules/AudioSystem.js†L1269-L1324】 | Fallback em caso de falha mantém `initialized=false`; serviço de sessão deve tratar ausência sem travar countdown/retry. |

### 9.3 IDs de DOM sob responsabilidade temporária da sessão
- Canvas/base: `#game-canvas` (bootstrap do contexto). 【F:src/app.js†L690-L707】
- Controles de run: botões `#start-game-btn`, `#restart-game-btn`, `#retry-game-btn`, `#quit-game-btn`, `#open-settings-btn`, `#menu-credits-btn`. 【F:src/app.js†L764-L812】
- Indicadores de retry: `#retry-count`, `#retry-countdown` (criado dinamicamente), botão `#retry-game-btn` para (re)habilitar durante start/retry. 【F:src/app.js†L783-L902】【F:src/app.js†L618-L682】
- Overlays exibidos/ocultados diretamente: `#game-ui`, `#gameover-screen`, além do uso indireto dos overlays de pausa/créditos via `UISystem`. 【F:src/app.js†L596-L681】【F:src/app.js†L889-L903】

Enquanto o `UISystem` não absorver o fluxo completo, o futuro `GameSessionService` deve continuar guardando referências/garantindo existência desses IDs antes de delegar para a UI refatorada.
