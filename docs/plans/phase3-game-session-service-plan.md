# Plano de Execução – Fase 3 (GameSessionService e isolamento do estado da sessão)

## 1. Objetivos da fase
- Consolidar todo o ciclo de sessão (start, pause, morte, retry, quit) em um `GameSessionService` registrado via manifesto/DI, removendo orquestração direta de `app.js` e mantendo o loop principal focado apenas em bootstrap/render.【F:src/app.js†L20-L33】【F:src/app.js†L880-L1072】
- Centralizar snapshots, restauração e resets de sistemas no novo serviço, garantindo coordenação com o RNG seedado e com os serviços de gameplay/UI já existentes.【F:src/app.js†L204-L249】【F:src/app.js†L386-L682】
- Preservar compatibilidade com módulos que consultam `game-state` e eventos globais (`UISystem`, `AudioSystem`, etc.), expondo uma API explícita para estado da run, seeds atuais e ponte com o DOM enquanto `UISystem` assume a UI interativa.【F:src/bootstrap/serviceManifest.js†L35-L55】【F:src/modules/UISystem.js†L994-L1060】【F:src/modules/AudioSystem.js†L181-L235】

## 2. Diagnóstico atual (evidências)
1. `app.js` acumula responsabilidades de estado global (`gameState`), resets em lote, controle de tela e persistência de seed, misturando infraestrutura com regras de sessão.【F:src/app.js†L20-L33】【F:src/app.js†L386-L427】【F:src/app.js†L703-L738】
2. Fluxos de morte/retry manipulam serviços e DOM diretamente (`createDeathSnapshot`, `executeRetryRespawn`, countdown), dificultando reutilização ou testes isolados.【F:src/app.js†L440-L682】
3. Listeners de DOM e eventos globais vivem em `app.js`, acionando funções internas ao invés de uma API dedicada; isso impede reutilizar o fluxo para outros inputs (ex.: comandos remotos).【F:src/app.js†L764-L867】
4. O manifesto disponibiliza um serviço `game-state` mínimo (get/set) que não acompanha seeds, snapshots ou timers da sessão, deixando consumidores cegos quanto ao status real da run.【F:src/bootstrap/serviceManifest.js†L35-L55】
5. Sistemas de gameplay já oferecem `reset`/`respawn` mas esperam coordenação externa: Player, Progression, Enemy, Physics, XP Orbs, Health Hearts e World carecem de um orquestrador que chame reset, restaure stats ou reconfigure caches no momento certo.【F:src/modules/PlayerSystem.js†L954-L998】【F:src/modules/ProgressionSystem.js†L1079-L1094】【F:src/modules/EnemySystem.js†L1599-L1614】【F:src/modules/PhysicsSystem.js†L694-L717】【F:src/modules/XPOrbSystem.js†L2002-L2027】【F:src/modules/collectibles/HealthHeartSystem.js†L107-L112】【F:src/modules/WorldSystem.js†L145-L189】
6. O fluxo de start/quit e o game loop dependem de `gameState.screen/isPaused`; se movermos o estado sem atualizar quem consulta (loop, UI, áudio), veremos frames processados quando não deveria ou menus inconsistentes.【F:src/app.js†L880-L1072】【F:src/modules/UISystem.js†L2842-L2855】【F:src/modules/AudioSystem.js†L181-L235】
7. Snapshots assumem APIs opcionais (`progression.restoreState`, `enemies.getSnapshotState`, `physics.restoreSnapshotState`) que hoje retornam `undefined` por falta de implementação; o novo serviço precisa padronizar fallback ou fornecer implementações baseadas em `serialize/deserialize`.【F:src/app.js†L471-L527】【F:src/modules/EnemySystem.js†L742-L808】【F:src/modules/ProgressionSystem.js†L1098-L1119】

## 3. Estratégia geral
- Introduzir `GameSessionService` como serviço singleton não lazy, recebendo via injeção o event bus, RNG, UI, Player, Progression, Enemy, Physics, XP Orbs, HealthHearts, World e Audio; manter acesso ao `manifestContext.gameState` apenas como storage legado/compatibilidade.
- Migrar gradualmente funções de `app.js` (seed scoping, resets, start/exit, snapshot, retry, listeners) para o serviço, expondo métodos públicos (`initialize`, `startNewRun`, `handlePlayerDeath`, `requestRetry`, `exitToMenu`, `togglePause`) e emitindo eventos padronizados.
- Atualizar `createServiceManifest`/`ServiceRegistry` para registrar o novo serviço e adaptar `game-state` para ser um facade sobre `GameSessionService` (delegando getters/setters e expondo seed/timestamp) mantendo `gameServices.register` ativo para legado.
- Deixar `app.js` responsável só por bootstrap DI, criação do canvas/loop e pela injeção do serviço (resolvendo-o após o bootstrap para chamar `initialize`), mantendo `performanceMonitor`, guardião de `Math.random()` e o `requestAnimationFrame`.

## 4. Sequenciamento detalhado
| Ordem | Passo | Descrição | Pré-requisito | Critério de aceite |
|-------|-------|-----------|---------------|--------------------|
| 1 | Mapear dependências | Inventariar todos os pontos de acesso que o serviço precisará (RNG, UI, Player, Progression, Enemy, Physics, XP Orbs, HealthHearts, World, Audio, DOM IDs) e documentar contratos esperados (reset, serialize, etc.). | — | Documento interno/trechos comentados no PR descrevendo dependências e fallback planejado. |
| 2 | Registrar `GameSessionService` | Criar o arquivo do serviço, registrá-lo no manifesto/ServiceRegistry com dependências corretas e sincronizar com `gameServices`/adapter para consumo legado. Ajustar `game-state` para delegar ao serviço. | Passo 1 | `diContainer.resolve('game-session')` retorna instância funcional; `gameServices.get('game-session')` funciona. |
| 3 | Migrar gerenciamento de seed/snapshots | Mover `prepareRandomForScope`, `logRandomSnapshot`, sincronização com áudio e persistência de seed para o serviço, expondo métodos utilitários e armazenando último snapshot; ajustar `app.js` para usar a API nova. | Passo 2 | Logs de seed continuam aparecendo e retry/start mantêm determinismo. |
| 4 | Migrar resets/snapshot de sistemas | Transferir `resetGameSystems`, `createDeathSnapshot`, `restoreFromSnapshot`, `findSafeSpawnPoint` para o serviço; implementar/ajustar serialização mínima em Progression/Enemies/Physics quando inexistente, garantindo fallback seguro. | Passo 3 | Retry restaura estado visível (XP, upgrades, asteroides) sem regressões; testes manuais confirmam. |
| 5 | Mover ciclo de run (start/exit/retry) | Implementar métodos `startNewRun`, `exitToMenu`, `performExit`, `beginRetryCountdown`, `completeRetryRespawn` dentro do serviço e atualizar `app.js`/listeners para chamá-los. | Passo 4 | Botões de menu/retry continuam funcionando; logs antigos aparecem uma única vez. |
| 6 | Centralizar listeners e timers | Relocar `setupDomEventListeners`, `setupGlobalEventListeners` e o controle de pause para o serviço, garantindo reemissão de `pause-state-changed` e uso do event bus. | Passo 5 | `toggle-pause`, `exit-to-menu-requested` e `player-died` disparam o serviço, com UI/áudio respondendo normalmente. |
| 7 | Higienizar `app.js` | Remover responsabilidades migradas, deixar `init()` focado em bootstrap, resolução do serviço e início do loop; garantir que `gameLoop` consulte estado via serviço (direto ou via `gameState`). | Passo 6 | `app.js` fica restrito a ~bootstrap/loop; cobertura manual confirma ausência de regressões. |
| 8 | Instrumentação e testes | Atualizar `ServiceRegistry.createTestContainer` com stub da sessão, preparar casos de teste manuais (start -> morrer -> retry -> quit) e validar seeds persistidos/localStorage. | Passos 6-7 | Checklist de validação preenchido incluindo fluxo de retry/quit, sem erros no console. |

## 5. Ajustes específicos por componente
- **`app.js`:** Após migrar funções, manter apenas bootstrap, loop, `performanceMonitor` e vínculo com canvas/contexto. Trocar acessos diretos a `gameState` (screen/pause/seed) por chamadas ao serviço ou ao facade `game-state`. O loop deve consultar `gameSession.isRunning()`/`isPaused()` para decidir `updateGame`, preservando resets do monitor.【F:src/app.js†L684-L1072】
- **`GameSessionService` (novo):** Estruturar estado interno com campos equivalentes aos atuais (`screen`, `isPaused`, `deathSnapshot`, `randomSeed`, `randomScope`, timers) e expor métodos idempotentes. Ele deve injetar serviços necessários e manter referências DOM cacheadas para countdown/botões, evitando buscas repetidas. Responsável por: preparar RNG por escopo, resetar serviços em ordem segura, restaurar snapshots, coordenar UI (`ui.showGameUI`, `ui.showScreen`), iniciar áudio e atualizar contadores de retry.【F:src/app.js†L204-L994】【F:src/modules/UISystem.js†L2842-L2855】【F:src/modules/AudioSystem.js†L181-L235】
- **`createServiceManifest`/`ServiceRegistry`:** Adicionar entrada `game-session` (singleton, lazy=false) após registrar dependências base (event bus, random, game-state) e antes dos sistemas que o serviço controla. Atualizar `ensureGameStateService` para delegar a `gameSession` quando disponível, mantendo fallback para `gameState` bruto durante bootstrap.【F:src/bootstrap/serviceManifest.js†L35-L205】
- **Sistemas de gameplay:** Confirmar que cada `reset` limpa estado e dispara eventos (Player, Progression, Enemies, Physics, XP Orbs, HealthHearts, World). Expandir com snapshots quando necessário: usar `ProgressionSystem.serialize()/deserialize` para `restoreState`; criar métodos `EnemySystem.exportState()`/`importState()` baseados em `waveState`/`sessionStats`; em `PhysicsSystem`, capturar/restaurar asteroides via `activeAsteroids` + seeds dos geradores; fornecer fallback caso ainda não implementado (limpeza completa + respawn).【F:src/modules/PlayerSystem.js†L954-L998】【F:src/modules/ProgressionSystem.js†L1079-L1119】【F:src/modules/EnemySystem.js†L742-L1723】【F:src/modules/PhysicsSystem.js†L694-L717】
- **Eventos globais:** `GameSessionService` deve ouvir `player-died`, `toggle-pause`, `exit-to-menu-requested` e outros sinais relevantes, evitando duplicidade com `WorldSystem` (que já emite `player-died`). Ele também deve reemitir `pause-state-changed` e atualizar `screen` via event bus para que UI/Áudio reajam.【F:src/modules/WorldSystem.js†L145-L189】【F:src/modules/UISystem.js†L994-L1060】【F:src/modules/AudioSystem.js†L181-L235】
- **Random/Seeds:** Preservar `persistLastSeed`, snapshots de RNG e sincronização com áudio (`reseedRandomScopes`). O serviço deve armazenar o snapshot atual e expor método `getRandomSnapshot()` para debugging, garantindo que `retry` restaure o mesmo estado ao chamar `random.restore()`.【F:src/app.js†L204-L249】【F:src/app.js†L703-L738】
- **Retry Countdown:** Encapsular criação e limpeza do elemento `#retry-countdown` no serviço, evitando vazamentos. Permitir customização futura (ex.: animação no UI) emitindo evento `session-retry-countdown` ao invés de mexer diretamente no DOM, mantendo fallback atual enquanto a UI não assume. 【F:src/app.js†L586-L682】
- **UI/Áudio integração:** Garantir que `ui.showGameUI()`, `ui.showScreen('menu')`, `ui.resetLevelUpState()` e `audio.init()` sejam acionados via serviço, respeitando ordem (UI antes de liberar input, áudio apenas em runs novas). Ao sair para o menu via pausa, preservar explosão épica controlada pelo serviço (incluindo `_quitExplosionHidden`).【F:src/app.js†L880-L994】【F:src/modules/UISystem.js†L2842-L2855】
- **Testabilidade:** Atualizar `ServiceRegistry.createTestContainer` para permitir injetar stub de `game-session` (com métodos no-op) e seeds fixos. Preparar scripts de smoke test manual cobrindo ciclo completo: start → jogar → morrer → retry → sair. 【F:src/core/ServiceRegistry.js†L30-L118】

## 6. Validação e monitoramento
- **Check manual de ciclo completo:** Start -> coletar XP -> morrer -> aguardar game over -> retry -> confirmar restauração de upgrades/seed -> quit para menu -> iniciar nova run.
- **Logs determinísticos:** Verificar console para snapshots `[Random]` em cada transição (bootstrap, run.start, retry.respawn, menu.exit) garantindo que `GameSessionService` imprima escopos consistentes.【F:src/app.js†L204-L994】
- **PerformanceMonitor:** Confirmar que métricas continuam atualizando apenas quando `screen === 'playing'` e não durante menus/pausa, ajustando consultas ao serviço conforme necessário.【F:src/app.js†L996-L1042】
- **Persistência de seed:** Validar que `persistLastSeed` continua gravando/recuperando localStorage após a migração. 【F:src/app.js†L68-L131】

## 7. Riscos e mitigação
- **APIs de snapshot incompletas:** Como `createDeathSnapshot` depende de métodos opcionais, precisamos implementar serialização real (Progression, Enemies, Physics) ou documentar fallback consistente (reset + respawn determinístico). Mitigar adicionando testes de restauração e logs quando determinado subsistema não oferecer snapshot.【F:src/app.js†L471-L527】【F:src/modules/EnemySystem.js†L742-L808】
- **Desalinhamento com o loop:** Se `gameLoop` continuar lendo `gameState` enquanto o serviço mantém seu próprio estado, podemos atualizar frames durante menus. Mitigar expondo getters no serviço e sincronizando `gameState` legado sempre que `screen`/`isPaused` mudar.【F:src/app.js†L996-L1072】
- **Eventos duplicados ou perdidos:** Ao mover listeners, há risco de emitir `pause-state-changed` múltiplas vezes ou esquecer de cancelar timeouts da explosão épica. Mitigar centralizando timers no serviço e adicionando guardas (`if (this.currentScreen === ...) return`).【F:src/app.js†L915-L994】【F:src/modules/AudioSystem.js†L181-L235】
- **Dependência no DOM direto:** Enquanto UI não absorver o countdown, manipulações diretas do DOM devem ser encapsuladas e limpas no `destroy`. Planejar transição futura emitindo eventos específicos para o `UISystem`.【F:src/app.js†L586-L682】【F:src/modules/UISystem.js†L994-L1060】

## 8. Checklist de saída da Fase 3
- [ ] `GameSessionService` registrado no manifesto e exposto via DI/Service Locator, substituindo funções de sessão em `app.js`.
- [ ] `app.js` reduzido a bootstrap, seed inicial, loop e logs, delegando ciclo de sessão ao serviço.
- [ ] Fluxos de start, pausa, morte, retry e quit operando através do serviço com snapshots/seed restaurados.
- [ ] Facade `game-state` e consumidores (`UISystem`, `AudioSystem`, testes) funcionando com a nova fonte de verdade.
- [ ] Séries de resets e restauradores dos sistemas críticos (Player, Progression, Enemy, Physics, XP Orbs, Health Hearts, World) validadas após retry.
- [ ] Logs e persistência de seed confirmados; checklist de validação (docs/validation) atualizado com cenário de retry/quitting.
