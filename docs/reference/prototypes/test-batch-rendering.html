<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Batch Rendering Performance Test</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #000;
            color: #fff;
            font-family: 'Courier New', monospace;
        }

        #test-canvas {
            border: 1px solid #333;
            background: #000;
        }

        .stats {
            margin: 20px 0;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
        }

        .stat-box {
            background: #111;
            padding: 15px;
            border-radius: 5px;
            border-left: 4px solid #0ff;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #0ff;
        }

        .controls {
            margin: 20px 0;
        }

        button {
            background: #333;
            color: #fff;
            border: 1px solid #555;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 3px;
            cursor: pointer;
        }

        button:hover {
            background: #555;
        }

        button.active {
            background: #0ff;
            color: #000;
        }

        .log {
            background: #111;
            padding: 15px;
            border-radius: 5px;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
            font-size: 12px;
        }

        .success { color: #0f0; }
        .warning { color: #ff0; }
        .error { color: #f00; }
    </style>
</head>
<body>
    <h1>ðŸš€ Batch Rendering Performance Test</h1>

    <div class="controls">
        <button id="start-test">Start Performance Test</button>
        <button id="toggle-batch">Toggle Batch Rendering: <span id="batch-status">ON</span></button>
        <button id="clear-log">Clear Log</button>
        <select id="scenario-select">
            <option value="light">Light (50 bullets, 100 particles)</option>
            <option value="medium">Medium (150 bullets, 300 particles)</option>
            <option value="heavy">Heavy (300 bullets, 600 particles)</option>
            <option value="stress">Stress (500 bullets, 1000 particles)</option>
        </select>
    </div>

    <canvas id="test-canvas" width="800" height="600"></canvas>

    <div class="stats">
        <div class="stat-box">
            <div>Frame Time</div>
            <div class="stat-value" id="frame-time">0.00ms</div>
        </div>
        <div class="stat-box">
            <div>FPS</div>
            <div class="stat-value" id="fps">0</div>
        </div>
        <div class="stat-box">
            <div>Objects Rendered</div>
            <div class="stat-value" id="objects-count">0</div>
        </div>
        <div class="stat-box">
            <div>Batch Efficiency</div>
            <div class="stat-value" id="batch-efficiency">0%</div>
        </div>
    </div>

    <div class="log" id="log"></div>

    <script type="module">
        // Import our rendering optimization classes
        import RenderBatch from '../../src/core/RenderBatch.js';
        import CanvasStateManager from '../../src/core/CanvasStateManager.js';
        import GradientCache from '../../src/core/GradientCache.js';

        class PerformanceTest {
            constructor() {
                this.canvas = document.getElementById('test-canvas');
                this.ctx = this.canvas.getContext('2d');

                // Optimization systems
                this.renderBatch = new RenderBatch();
                this.stateManager = new CanvasStateManager();
                this.gradientCache = new GradientCache();

                // Test state
                this.useBatchRendering = true;
                this.running = false;
                this.scenario = 'medium';
                this.objects = [];

                // Performance tracking
                this.frameCount = 0;
                this.frameTimeSum = 0;
                this.lastFrameTime = 0;
                this.lastFPS = 0;

                this.setupEventListeners();
                this.initializeRendering();
                this.generateTestObjects();
                this.startRenderLoop();

                this.log('ðŸŽ® Batch Rendering Test Initialized', 'success');
            }

            initializeRendering() {
                this.stateManager.initialize(this.ctx);
                this.gradientCache.preloadGradients(this.ctx);
            }

            setupEventListeners() {
                document.getElementById('start-test').addEventListener('click', () => this.runPerformanceTest());
                document.getElementById('toggle-batch').addEventListener('click', () => this.toggleBatchRendering());
                document.getElementById('clear-log').addEventListener('click', () => this.clearLog());
                document.getElementById('scenario-select').addEventListener('change', (e) => this.changeScenario(e.target.value));
            }

            toggleBatchRendering() {
                this.useBatchRendering = !this.useBatchRendering;
                document.getElementById('batch-status').textContent = this.useBatchRendering ? 'ON' : 'OFF';
                document.getElementById('toggle-batch').classList.toggle('active', this.useBatchRendering);
                this.log(`ðŸ”„ Batch Rendering: ${this.useBatchRendering ? 'ENABLED' : 'DISABLED'}`, 'warning');
            }

            changeScenario(scenario) {
                this.scenario = scenario;
                this.generateTestObjects();
                this.log(`ðŸ“Š Scenario changed to: ${scenario.toUpperCase()}`, 'warning');
            }

            generateTestObjects() {
                const scenarios = {
                    light: { bullets: 50, particles: 100, enemies: 20 },
                    medium: { bullets: 150, particles: 300, enemies: 50 },
                    heavy: { bullets: 300, particles: 600, enemies: 100 },
                    stress: { bullets: 500, particles: 1000, enemies: 200 }
                };

                const config = scenarios[this.scenario];
                this.objects = [];

                // Generate bullets
                for (let i = 0; i < config.bullets; i++) {
                    this.objects.push({
                        type: 'bullet',
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        radius: 2 + Math.random() * 3,
                        vx: (Math.random() - 0.5) * 4,
                        vy: (Math.random() - 0.5) * 4,
                        color: '#FFFFFF',
                        glow: '#FFFF00'
                    });
                }

                // Generate particles
                for (let i = 0; i < config.particles; i++) {
                    this.objects.push({
                        type: 'particle',
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        radius: 1 + Math.random() * 2,
                        vx: (Math.random() - 0.5) * 2,
                        vy: (Math.random() - 0.5) * 2,
                        color: `hsl(${Math.random() * 60 + 20}, 70%, 60%)`,
                        alpha: 0.4 + Math.random() * 0.6
                    });
                }

                // Generate enemies
                for (let i = 0; i < config.enemies; i++) {
                    this.objects.push({
                        type: 'enemy',
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        radius: 8 + Math.random() * 12,
                        vx: (Math.random() - 0.5) * 1,
                        vy: (Math.random() - 0.5) * 1,
                        color: '#FF4444',
                        strokeColor: '#FF0000'
                    });
                }

                document.getElementById('objects-count').textContent = this.objects.length;
            }

            updateObjects() {
                for (const obj of this.objects) {
                    obj.x += obj.vx;
                    obj.y += obj.vy;

                    // Wrap around screen
                    if (obj.x < 0) obj.x = this.canvas.width;
                    if (obj.x > this.canvas.width) obj.x = 0;
                    if (obj.y < 0) obj.y = this.canvas.height;
                    if (obj.y > this.canvas.height) obj.y = 0;
                }
            }

            renderLegacy() {
                // Traditional rendering (individual draw calls)
                for (const obj of this.objects) {
                    if (obj.type === 'bullet') {
                        // Glow effect
                        const gradient = this.ctx.createRadialGradient(
                            obj.x, obj.y, 0,
                            obj.x, obj.y, obj.radius * 3
                        );
                        gradient.addColorStop(0, obj.glow);
                        gradient.addColorStop(1, 'rgba(255, 255, 0, 0)');

                        this.ctx.fillStyle = gradient;
                        this.ctx.beginPath();
                        this.ctx.arc(obj.x, obj.y, obj.radius * 3, 0, Math.PI * 2);
                        this.ctx.fill();

                        // Core
                        this.ctx.fillStyle = obj.color;
                        this.ctx.beginPath();
                        this.ctx.arc(obj.x, obj.y, obj.radius, 0, Math.PI * 2);
                        this.ctx.fill();

                    } else if (obj.type === 'particle') {
                        this.ctx.globalAlpha = obj.alpha;
                        this.ctx.fillStyle = obj.color;
                        this.ctx.beginPath();
                        this.ctx.arc(obj.x, obj.y, obj.radius, 0, Math.PI * 2);
                        this.ctx.fill();
                        this.ctx.globalAlpha = 1;

                    } else if (obj.type === 'enemy') {
                        this.ctx.fillStyle = obj.color;
                        this.ctx.strokeStyle = obj.strokeColor;
                        this.ctx.lineWidth = 2;
                        this.ctx.beginPath();
                        this.ctx.arc(obj.x, obj.y, obj.radius, 0, Math.PI * 2);
                        this.ctx.fill();
                        this.ctx.stroke();
                    }
                }
            }

            renderBatched() {
                // Group objects by type
                const bullets = this.objects.filter(obj => obj.type === 'bullet');
                const particles = this.objects.filter(obj => obj.type === 'particle');
                const enemies = this.objects.filter(obj => obj.type === 'enemy');

                // Batch render bullets
                if (bullets.length > 0) {
                    this.renderBatch.beginBatch('bullets', { fillStyle: '#FFFFFF' });
                    for (const bullet of bullets) {
                        this.renderBatch.addCircle(bullet.x, bullet.y, bullet.radius, bullet.color);
                    }
                    this.renderBatch.flushBatch(this.ctx);
                }

                // Batch render particles
                if (particles.length > 0) {
                    this.renderBatch.beginBatch('particles', { globalAlpha: 0.8 });
                    for (const particle of particles) {
                        this.renderBatch.addCircle(particle.x, particle.y, particle.radius, particle.color);
                    }
                    this.renderBatch.flushBatch(this.ctx);
                }

                // Batch render enemies
                if (enemies.length > 0) {
                    this.renderBatch.beginBatch('enemies', { lineWidth: 2 });
                    for (const enemy of enemies) {
                        this.renderBatch.addCircle(enemy.x, enemy.y, enemy.radius, enemy.color, enemy.strokeColor);
                    }
                    this.renderBatch.flushBatch(this.ctx);
                }
            }

            render() {
                const frameStart = performance.now();

                // Clear canvas
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Update objects
                this.updateObjects();

                // Render using selected method
                if (this.useBatchRendering) {
                    this.renderBatched();
                } else {
                    this.renderLegacy();
                }

                // Update performance stats
                const frameTime = performance.now() - frameStart;
                this.frameCount++;
                this.frameTimeSum += frameTime;
                this.lastFrameTime = frameTime;

                if (this.frameCount % 60 === 0) {
                    this.lastFPS = Math.round(1000 / (this.frameTimeSum / 60));
                    this.frameTimeSum = 0;
                    this.updateUI();
                }
            }

            updateUI() {
                document.getElementById('frame-time').textContent = this.lastFrameTime.toFixed(2) + 'ms';
                document.getElementById('fps').textContent = this.lastFPS;

                if (this.useBatchRendering) {
                    const batchStats = this.renderBatch.getStats();
                    document.getElementById('batch-efficiency').textContent = batchStats.efficiency;
                } else {
                    document.getElementById('batch-efficiency').textContent = 'N/A';
                }
            }

            startRenderLoop() {
                const loop = () => {
                    this.render();
                    requestAnimationFrame(loop);
                };
                loop();
            }

            async runPerformanceTest() {
                this.log('ðŸ§ª Starting comprehensive performance test...', 'warning');

                const scenarios = ['light', 'medium', 'heavy', 'stress'];
                const results = {};

                for (const scenario of scenarios) {
                    this.log(`ðŸ“Š Testing ${scenario.toUpperCase()} scenario...`);

                    this.scenario = scenario;
                    this.generateTestObjects();

                    // Test without batching
                    this.useBatchRendering = false;
                    const legacyTime = await this.measurePerformance(1000); // 1 second

                    // Test with batching
                    this.useBatchRendering = true;
                    const batchedTime = await this.measurePerformance(1000); // 1 second

                    const improvement = ((legacyTime - batchedTime) / legacyTime * 100).toFixed(1);
                    results[scenario] = {
                        legacy: legacyTime,
                        batched: batchedTime,
                        improvement: improvement
                    };

                    this.log(`  Legacy: ${legacyTime.toFixed(2)}ms, Batched: ${batchedTime.toFixed(2)}ms`);
                    this.log(`  ðŸš€ Improvement: ${improvement}%`, improvement > 0 ? 'success' : 'error');
                }

                // Calculate average improvement
                const improvements = Object.values(results).map(r => parseFloat(r.improvement));
                const avgImprovement = improvements.reduce((a, b) => a + b, 0) / improvements.length;

                this.log('\nðŸŽ¯ PERFORMANCE TEST RESULTS', 'success');
                this.log('============================');
                for (const [scenario, data] of Object.entries(results)) {
                    this.log(`${scenario.toUpperCase()}: ${data.improvement}% improvement`);
                }
                this.log(`\nðŸ† AVERAGE IMPROVEMENT: ${avgImprovement.toFixed(1)}%`, 'success');

                const targetMet = avgImprovement >= 30;
                this.log(`ðŸŽ¯ TARGET (30%+): ${targetMet ? 'âœ… ACHIEVED' : 'âŒ NOT MET'}`, targetMet ? 'success' : 'error');

                return results;
            }

            measurePerformance(durationMs) {
                return new Promise((resolve) => {
                    const measurements = [];
                    const startTime = performance.now();

                    const measure = () => {
                        const frameStart = performance.now();
                        this.render();
                        const frameTime = performance.now() - frameStart;
                        measurements.push(frameTime);

                        if (performance.now() - startTime < durationMs) {
                            requestAnimationFrame(measure);
                        } else {
                            const avgTime = measurements.reduce((a, b) => a + b, 0) / measurements.length;
                            resolve(avgTime);
                        }
                    };

                    measure();
                });
            }

            log(message, type = 'info') {
                const logElement = document.getElementById('log');
                const timestamp = new Date().toLocaleTimeString();
                const line = `[${timestamp}] ${message}\n`;

                const span = document.createElement('span');
                span.className = type;
                span.textContent = line;

                logElement.appendChild(span);
                logElement.scrollTop = logElement.scrollHeight;
            }

            clearLog() {
                document.getElementById('log').innerHTML = '';
            }
        }

        // Start the test when page loads
        window.addEventListener('load', () => {
            new PerformanceTest();
        });
    </script>
</body>
</html>