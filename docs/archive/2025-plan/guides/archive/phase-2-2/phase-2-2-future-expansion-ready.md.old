> [!NOTE]
Documento arquivado em 2025-10-10. Itens rastreados no novo plano: SeÃ§Ã£o 4.1 MigraÃ§Ã£o DI + WaveManager. Consulte `docs/plans/docs-implementation-master-plan.md` para objetivos e critÃ©rios atualizados.

# Fase 2.2: Arquitetura Preparada para ExpansÃ£o

> **Estado:** Arquivado. A avaliaÃ§Ã£o atualizada encontra-se em
> [`docs/guides/phase-2-2-actual-state.md`](../../phase-2-2-actual-state.md).

**Data:** 2025-10-01
**Status:** âœ… Fase 2.2.1 Completa | Arquitetura Pronta para Novos Enemy Types
**DecisÃ£o:** MANTER cÃ³digo preparatÃ³rio (EnemyFactory, WaveManager) para expansÃ£o futura

---

## ğŸ¯ Objetivo do Projeto

**Expandir com:**
- Novos tipos de inimigos (drones, ships, etc.)
- Bosses
- Sistemas de waves complexos
- MÃºltiplos tipos coexistindo

**Portanto:** A arquitetura de componentes Ã© ESSENCIAL e deve ser mantida!

---

## âœ… Estado Atual da Arquitetura

### Componentes ATIVOS e Funcionando

#### 1. AsteroidMovement âœ…
**Status:** ATIVO via `useComponents = true`
**Linhas:** 275
**Responsabilidade:** Movimento de asteroids (linear, parasite, volatile)
**Pronto para:** Reutilizar para outros enemy types

**Como usar para novo enemy:**
```javascript
// Novo enemy pode usar o mesmo component
this.movementComponent.update(droneEnemy, deltaTime, context);
```

#### 2. AsteroidCollision âœ…
**Status:** ATIVO via `useComponents = true`
**Linhas:** 241
**Responsabilidade:** FÃ­sica de colisÃ£o elÃ¡stica entre asteroids
**Pronto para:** ColisÃµes entre diferentes enemy types

#### 3. AsteroidRenderer âœ…
**Status:** ATIVO via `useComponents = true`
**Linhas:** 201
**Responsabilidade:** RenderizaÃ§Ã£o de asteroids
**Pronto para:** Renderer de outros enemy types

#### 4. RewardManager âœ…
**Status:** ATIVO via event `enemy-destroyed`
**Linhas:** 339
**Responsabilidade:** Sistema de drops (XP orbs)
**Pronto para:** Drops de qualquer enemy type

**Total ATIVO:** 1,056 linhas

---

### Componentes PREPARADOS mas NÃ£o Ativos

#### 5. EnemyFactory â¸ï¸ PREPARADO PARA EXPANSÃƒO
**Status:** Inicializado mas `useFactory = false`
**Linhas:** 428
**Responsabilidade:** Factory Pattern para criar diferentes enemy types

**Por que nÃ£o estÃ¡ ativo:**
- Sistema atual sÃ³ tem asteroids
- GamePools jÃ¡ gerencia pooling adequadamente
- Factory serÃ¡ essencial quando adicionar segundo enemy type

**Como estÃ¡ estruturado:**
```javascript
// EnemySystem.js
this.factory = new EnemyFactory(this);

// Registrar tipo
this.factory.registerType('asteroid', {
  class: Asteroid,
  pool: GamePools?.asteroids || null,
  defaults: { size: 'medium', variant: 'common' },
  tags: ['destructible', 'enemy']
});

// Criar instance (quando useFactory = true)
const enemy = this.factory.create('asteroid', config);
```

**QUANDO ATIVAR:**
Quando vocÃª implementar o **segundo enemy type** (drone, boss, etc.)

**Como ativar:**
```javascript
// 1. Registrar novo tipo
this.factory.registerType('drone', {
  class: Drone,
  pool: GamePools.drones,
  defaults: { weapon: 'laser' },
  tags: ['destructible', 'enemy', 'flying']
});

// 2. Ativar flag
this.useFactory = true;

// 3. Usar em spawning
const drone = this.factory.create('drone', {
  x: 100,
  y: 200,
  weapon: 'plasma'
});
```

---

#### 6. WaveManager â¸ï¸ PREPARADO PARA WAVES COMPLEXOS
**Status:** Inicializado mas nÃ£o integrado no game loop
**Linhas:** 447
**Responsabilidade:** Gerenciamento avanÃ§ado de waves

**Por que nÃ£o estÃ¡ ativo:**
- Sistema legado de waves funciona bem para asteroids apenas
- WaveManager foi preparado para waves com mÃºltiplos enemy types
- Precisa adaptaÃ§Ã£o para manter gameplay atual

**Como estÃ¡ estruturado:**
```javascript
// EnemySystem.js
this.waveManager = new WaveManager(this, gameEvents);

// WaveManager tem:
- loadWaveConfigurations() // Waves prÃ©-definidas
- generateDynamicWave()     // Waves procedurais
- spawnWave()               // Spawning de mÃºltiplos tipos
- update()                  // Loop principal
```

**QUANDO ATIVAR:**
Quando vocÃª quiser waves complexas:
```javascript
// Wave com mÃºltiplos enemy types
{
  enemies: [
    { type: 'asteroid', count: 5, size: 'large', variant: 'common' },
    { type: 'drone', count: 3, weapon: 'laser' },
    { type: 'boss', count: 1, phase: 1 }
  ]
}
```

**Plano de ativaÃ§Ã£o existe:** [phase-2-2-2-wavemanager-activation-plan.md]

---

## ğŸ—ºï¸ Roadmap de ExpansÃ£o

### Fase 1: Adicionar Primeiro Novo Enemy Type (Ex: Drone) ğŸš€

**Estimativa:** 10-15 horas

**Passos:**
1. **Criar Drone.js** baseado em BaseEnemy
   - Herdar de BaseEnemy
   - Implementar movimento (pode reutilizar AsteroidMovement)
   - Implementar ataque (novo: shooting)

2. **Ativar EnemyFactory**
   - `useFactory = true`
   - Registrar tipo 'drone'
   - Testar criaÃ§Ã£o

3. **Adaptar Spawning**
   - Modificar wave logic para spawnar drones
   - Ou ativar WaveManager

4. **Testar IntegraÃ§Ã£o**
   - ColisÃµes drone-asteroid
   - ColisÃµes drone-player
   - Rewards de drones

**BenefÃ­cios:**
- âœ… Valida arquitetura de componentes
- âœ… Ativa EnemyFactory (agora faz sentido!)
- âœ… Gameplay mais rico

---

### Fase 2: Ativar WaveManager para Waves Complexas ğŸŒŠ

**Estimativa:** 6-8 horas

**Quando:** ApÃ³s ter 2+ enemy types

**O que fazer:**
1. Adaptar WaveManager para spawning gradual (plano jÃ¡ existe)
2. Criar wave configs com mÃºltiplos tipos
3. Integrar no game loop
4. Testar progressÃ£o

**Wave exemplo:**
```javascript
// Wave 5: Misto
{
  enemies: [
    { type: 'asteroid', count: 3, size: 'large' },
    { type: 'drone', count: 2, weapon: 'laser' },
  ]
}

// Wave 10: Boss
{
  enemies: [
    { type: 'asteroid', count: 5, size: 'small' }, // Adds
    { type: 'boss', count: 1, name: 'Titan' }
  ]
}
```

---

### Fase 3: Sistema de Bosses ğŸ‘¾

**Estimativa:** 15-20 horas

**Requer:**
- âœ… EnemyFactory ativo
- âœ… WaveManager ativo
- âœ… Sistema de fases (boss phases)

**Arquitetura preparada:**
- BaseEnemy jÃ¡ tem health system
- RewardManager jÃ¡ suporta qualquer enemy type
- Movement component reutilizÃ¡vel
- Collision system extensÃ­vel

---

## ğŸ“š CÃ³digo Legacy que Serve de Fallback

### Por Que Mantemos CÃ³digo "Duplicado"?

**Exemplo: checkAsteroidCollision() no EnemySystem**

```javascript
handleAsteroidCollisions() {
  if (this.useComponents && this.collisionComponent) {
    // CAMINHO ATIVO
    this.collisionComponent.handleAsteroidCollisions(this.asteroids);
  } else {
    // FALLBACK/LEGACY - Mantido para:
    // 1. Rollback fÃ¡cil se component der problema
    // 2. ReferÃªncia de como funcionava
    // 3. Debug/comparaÃ§Ã£o
    for (let i = 0; i < this.asteroids.length - 1; i++) {
      // ... lÃ³gica original
    }
  }
}
```

**NÃ£o Ã© "cÃ³digo morto" - Ã© "fallback path"!**

**BenefÃ­cios:**
- âœ… SeguranÃ§a (pode desabilitar component se der problema)
- âœ… ReferÃªncia (cÃ³digo original documentado)
- âœ… MigraÃ§Ã£o gradual (feature flags)

**Quando remover:**
- ApÃ³s 3-6 meses sem problemas com components
- Ou quando tiver confianÃ§a 100% na arquitetura nova

---

## ğŸ¯ Guia de Uso: Como Adicionar Novo Enemy Type

### Passo 1: Criar Classe do Enemy

```javascript
// src/modules/enemies/types/Drone.js
import { BaseEnemy } from '../base/BaseEnemy.js';

export class Drone extends BaseEnemy {
  constructor(system, config = {}) {
    super(system, config);
    this.type = 'drone';

    // Drone-specific properties
    this.weapon = config.weapon || 'laser';
    this.attackCooldown = 0;
    this.targetingRange = 300;
  }

  update(deltaTime) {
    if (this.destroyed) return;

    // Pode usar movement component
    // ou implementar movimento prÃ³prio
    this.updateTargeting(deltaTime);
    this.updateWeapon(deltaTime);
  }

  updateTargeting(deltaTime) {
    const player = this.system?.getCachedPlayer();
    if (!player) return;

    // Tracking logic
    const dx = player.position.x - this.x;
    const dy = player.position.y - this.y;
    const distance = Math.hypot(dx, dy);

    if (distance < this.targetingRange) {
      // Mover em direÃ§Ã£o ao player
      const dirX = dx / distance;
      const dirY = dy / distance;
      this.vx += dirX * 100 * deltaTime;
      this.vy += dirY * 100 * deltaTime;
    }
  }

  updateWeapon(deltaTime) {
    this.attackCooldown = Math.max(0, this.attackCooldown - deltaTime);

    if (this.attackCooldown === 0) {
      this.fireWeapon();
      this.attackCooldown = 2.0; // 2s cooldown
    }
  }

  fireWeapon() {
    // Emit evento para CombatSystem criar projectile
    if (typeof gameEvents !== 'undefined') {
      gameEvents.emit('enemy-fire', {
        enemy: this,
        weapon: this.weapon,
        position: { x: this.x, y: this.y }
      });
    }
  }

  draw(ctx) {
    // RenderizaÃ§Ã£o do drone
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.rotation);

    // Corpo do drone
    ctx.fillStyle = '#00ff00';
    ctx.fillRect(-15, -15, 30, 30);

    // Weapon indicator
    ctx.fillStyle = '#ff0000';
    ctx.fillRect(10, -3, 8, 6);

    ctx.restore();
  }
}
```

### Passo 2: Registrar no Factory

```javascript
// EnemySystem.js - setupEnemyFactory()
setupEnemyFactory() {
  this.factory = new EnemyFactory(this);

  // Asteroid (jÃ¡ existe)
  this.factory.registerType('asteroid', {
    class: Asteroid,
    pool: GamePools?.asteroids || null,
    defaults: { size: 'medium', variant: 'common' },
    tags: ['destructible', 'enemy']
  });

  // NEW: Drone
  this.factory.registerType('drone', {
    class: Drone,
    pool: GamePools?.drones || null, // Criar pool para drones
    defaults: { weapon: 'laser' },
    tags: ['destructible', 'enemy', 'shooter']
  });

  // ATIVAR FACTORY
  this.useFactory = true;
}
```

### Passo 3: Spawnar no Jogo

```javascript
// MÃ©todo de spawning
spawnDrone(x, y, config = {}) {
  if (!this.useFactory || !this.factory) {
    console.error('Factory not available');
    return null;
  }

  const drone = this.factory.create('drone', {
    x,
    y,
    weapon: config.weapon || 'laser',
    wave: this.waveState?.current || 1
  });

  if (drone) {
    this.enemies.push(drone); // Ou criar lista separada
    console.log('[EnemySystem] Spawned drone');
  }

  return drone;
}
```

### Passo 4: Integrar com Sistema de Waves

```javascript
// WaveManager ou EnemySystem
generateWaveConfig(waveNumber) {
  const enemies = [];

  // Asteroids
  enemies.push({
    type: 'asteroid',
    count: 5,
    size: 'large'
  });

  // Drones (aparecem a partir da wave 5)
  if (waveNumber >= 5) {
    enemies.push({
      type: 'drone',
      count: 2,
      weapon: 'laser'
    });
  }

  return { enemies };
}
```

---

## ğŸ“Š Arquitetura Final Desejada

```
EnemySystem (orchestrator)
â”œâ”€â”€ EnemyFactory (create different types) âœ… PREPARADO
â”‚   â”œâ”€â”€ Asteroid âœ… IMPLEMENTADO
â”‚   â”œâ”€â”€ Drone â³ PRÃ“XIMO
â”‚   â”œâ”€â”€ Ship â³ FUTURO
â”‚   â””â”€â”€ Boss â³ FUTURO
â”‚
â”œâ”€â”€ WaveManager (complex waves) â¸ï¸ PREPARADO
â”‚   â”œâ”€â”€ Wave configs (multi-type)
â”‚   â”œâ”€â”€ Gradual spawning
â”‚   â””â”€â”€ Difficulty scaling
â”‚
â”œâ”€â”€ Components (reusable logic) âœ… ATIVOS
â”‚   â”œâ”€â”€ AsteroidMovement (pode ser genÃ©rico)
â”‚   â”œâ”€â”€ AsteroidCollision (genÃ©rico)
â”‚   â””â”€â”€ AsteroidRenderer (pode ser genÃ©rico)
â”‚
â””â”€â”€ Managers (cross-cutting concerns) âœ… ATIVOS
    â””â”€â”€ RewardManager (drops para todos)
```

---

## ğŸ“ LiÃ§Ãµes Aprendidas da Fase 2.2

### âœ… O Que Funcionou Bem

1. **MigraÃ§Ã£o Gradual via Feature Flags**
   - `useComponents = true/false`
   - `useFactory = true/false`
   - `useManagers = true/false`
   - Permite ativar incrementalmente

2. **Manter CÃ³digo Legacy como Fallback**
   - SeguranÃ§a para rollback
   - ReferÃªncia do comportamento original
   - ComparaÃ§Ã£o para debug

3. **DocumentaÃ§Ã£o Detalhada**
   - Planos de ativaÃ§Ã£o
   - AnÃ¡lise de diferenÃ§as
   - Guias de uso

### ğŸ“ RecomendaÃ§Ãµes para ExpansÃ£o

1. **NÃ£o remova cÃ³digo preparatÃ³rio** se planeja usar em 3-6 meses
2. **Mantenha fallback paths** atÃ© ter confianÃ§a total
3. **Use feature flags** para ativaÃ§Ã£o gradual
4. **Documente intenÃ§Ãµes** (comentÃ¡rios de "por que nÃ£o estÃ¡ ativo")
5. **Teste extensivamente** antes de remover legacy code

---

## ğŸš€ PrÃ³ximos Passos Recomendados

### OpÃ§Ã£o A: Consolidar Atual (1-2 semanas)
1. Jogar e testar extensivamente o jogo atual
2. Coletar feedback sobre gameplay
3. Ajustar balance de asteroids/variants
4. Adicionar polish visual/audio

**Depois:** Expandir com drones

### OpÃ§Ã£o B: ComeÃ§ar ExpansÃ£o (2-3 semanas)
1. Projetar primeiro novo enemy (drone)
2. Implementar Drone.js
3. Ativar EnemyFactory
4. Testar interaÃ§Ã£o asteroids + drones

**BenefÃ­cio:** Valida arquitetura enquanto estÃ¡ fresca

### OpÃ§Ã£o C: Documentar e Pausar
1. Documentar estado atual (este arquivo!)
2. Criar guia de expansÃ£o
3. Pausar desenvolvimento por um tempo
4. Retornar quando quiser expandir

**BenefÃ­cio:** Flexibilidade, sem pressa

---

## ğŸ“ DocumentaÃ§Ã£o da DecisÃ£o

**Data:** 2025-10-01
**DecisÃ£o:** MANTER toda arquitetura preparatÃ³ria

**Justificativa:**
- Projeto tem objetivo de expansÃ£o (novos enemies, bosses)
- EnemyFactory serÃ¡ essencial para mÃºltiplos tipos
- WaveManager serÃ¡ essencial para waves complexas
- CÃ³digo estÃ¡ bem estruturado e documentado
- Remover agora = retrabalho futuro

**Trade-off Aceito:**
- Manter ~875 linhas de cÃ³digo nÃ£o ativo
- Em troca de: arquitetura preparada para expansÃ£o

**Status Atual:**
- âœ… Componentes ativos: 1,056 linhas funcionando
- â¸ï¸ Componentes preparados: 875 linhas aguardando uso
- ğŸ¯ Arquitetura pronta para novos enemy types

---

**DecisÃ£o correta para um projeto de expansÃ£o! ğŸš€**
