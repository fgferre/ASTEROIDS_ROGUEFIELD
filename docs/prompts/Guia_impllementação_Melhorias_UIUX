Guia de Implementação de Melhorias de UX/UI
Documento orientador para evoluir o ASTEROIDS_ROGUEFIELD em ciclos curtos, aderentes à política descrita em agents.md. Use cada etapa como insumo para abrir tarefas e PRs pequenos, sempre com validação explícita.

Panorama do estado atual (Atualizado em 2025-09-21)
Orquestração e ciclo de jogo

src/app.js instancia os sistemas manualmente, mantém o estado global (screen, isPaused) e chama update()/render() a cada frame. Não há um GameLoopSystem, portanto novos fluxos (tutorial, configurações, histórico) precisam conversar com o orquestrador via eventos ou acesso ao ServiceLocator.

Interface do usuário

UISystem centraliza HUD, telas (menu, pausa, level up, game over) e efeitos visuais (flash de dano, cooldown do escudo). Hoje o HUD é atualizado a cada update() por meio de document.getElementById, sem cache ou esquema de configuração.

O layout vive em src/index.html com estilos em src/style.css, que já oferece tokens de design (claro/escuro) aproveitáveis para acessibilidade e temas.

Áudio e feedback

AudioSystem possui masterGain único e múltiplos efeitos procedurais, mas sem canais separados (música, efeitos), sem ajustes de volume ou persistência.

Entrada e controle

InputSystem rastreia teclado/mouse e detecta gamepad apenas superficialmente. Bindings são fixos (WASD/setas/Esc/E) e não há remapeamento nem persistência.

Progressão e upgrades

ProgressionSystem calcula XP/orbes, controla level e aplica upgrades. SPACE_UPGRADES está hardcoded em GameConstants.js. A tela de level-up é montada diretamente no UISystem, sem dados estruturados adicionais (categoria, níveis, ícones alternativos).

Estatísticas e histórico

EnemySystem já coleta sessionStats (kills, tempo, ondas) e o WorldSystem propaga esses dados no evento player-died. Não existe sistema dedicado para guardar ou comparar partidas anteriores.

Efeitos visuais

EffectsSystem emite partículas/flash/shake com lógica acoplada; não há esquema data-driven que permita ajustar intensidade por configuração ou pelo futuro menu de opções.

Documentação e validação

Não existe docs/validation/test-checklist.md, embora agents.md exija validações explícitas.

historico_do_projeto.txt registra evolução arquitetural, mas o plano atual de UX/UI (em docs/prompts/Guia_impllementação_Melhorias_UIUX) não reflete as descobertas acima.

Princípios de execução (reforço de agents.md)
Dados centralizados: novos parâmetros devem ir para GameConstants.js ou arquivos em src/data/.

Comunicação desacoplada: continuar usando gameEvents e gameServices.

PRs atômicos e verificáveis: cada item abaixo deve resultar em mudanças pequenas, acompanhadas de atualização no checklist de testes e, quando aplicável, na documentação (agents.md, README.md, guias em /docs).

Sem dependências extras: privilegiar APIs nativas do browser e recursos já presentes no build toolchain (Vite, Grunt, Prettier).

Etapas propostas
Etapa 0 – Preparação e governança
Checklist de validação

Criar docs/validation/test-checklist.md descrevendo cenários mínimos para menu, HUD, telas de pausa/game over e futuras configurações. Referenciar sempre que uma etapa alterar a experiência do jogador.

Documentação de artefatos

Atualizar agents.md (ou criar apêndice em /docs) sempre que um novo sistema/evento for adicionado, mantendo o glossário vivo.

Inventário de eventos/UI

Mapear indicadores existentes (vida, escudo, XP, kills, tempo, ondas) com seus eventos/fontes atuais para guiar a etapa 1.

Etapa 1 – HUD unificado e data-driven
Objetivo: eliminar IDs “mágicos”, reduzir queries por frame e permitir reordenação/configuração do HUD por dados.

Tarefas:

Criar esquema (src/data/ui/hudLayout.js ou GameConstants.HUD_CONFIG) definindo chaves, rótulos, ícones, ordem e condições de visibilidade.

Refatorar UISystem:

Cachear referências de DOM no constructor.

Usar o novo esquema para popular o HUD (ex.: renderHudElement(config, stats)).

Assinar eventos existentes (player-health-changed, experience-changed, shield-stats-changed, wave-state-updated) para atualizar apenas quando necessário; manter fallback de update() para elementos sem evento específico.

Ajustar src/index.html e src/style.css:

Consolidar o HUD em um contêiner único reutilizando tokens (--color-*, --font-*).

Adicionar classes utilitárias para estados (perigo, cooldown, alerta).

Atualizar o checklist de testes com cenários de HUD (desktop e viewport reduzida).

Dependências: Etapa 0 (checklist pronto para ser atualizado).

Etapa 2 – Menu principal e tutorial interativo
Objetivo: melhorar onboarding e preparar caminho para configurações.

Tarefas:

Reorganizar menu-screen em index.html para incluir:

Botão “Configurações”.

Espaço reservado para tutorial e futuro fundo animado (CSS ou canvas leve via RenderingSystem).

Criar src/data/tutorialSteps.js descrevendo etapas (texto, elemento-alvo, ação esperada).

Implementar TutorialSystem em src/modules/:

Controlar a sequência de passos com base nos dados.

Pausar startGame() até emitir tutorial-completed.

Persistir conclusão em localStorage (detectar primeira execução).

Expor ganchos em app.js:

Antes de chamar startGame(), verificar se o tutorial deve rodar.

Permitir que TutorialSystem solicite transições de tela via gameEvents.

Atualizar checklist com cenários de tutorial (primeira execução, repetição).

Dependências: Etapa 1 (HUD consistente facilita instruções visuais).

Etapa 3 – Pausa e Configurações
Objetivo: dar controle ao jogador e abrir espaço para acessibilidade/áudio.

Tarefas:

Criar SettingsSystem (src/modules/SettingsSystem.js) com responsabilidades:

Schema em src/data/settingsSchema.js (categorias: áudio, controles, acessibilidade, vídeo).

Persistência (localStorage), defaults e validação de entrada.

API pública (getSetting, setSetting, subscribe) registrada no ServiceLocator.

Evoluir AudioSystem:

Separar ganhos (música, efeitos), adicionar eventos (settings-audio-changed) e persistir volumes via SettingsSystem.

Considerar canal futuro de “efeitos visuais” para reduzir particulados (integração com Etapa 7).

Refatorar InputSystem:

Criar camada de bindings configuráveis (ex.: this.bindings = { moveUp: ['w', 'arrowup'] }).

Permitir remapeamento via SettingsSystem (guardando preferências).

Iniciar suporte real a gamepad (polling no update()).

Atualizar telas de pausa/configurações:

Extrair lógica do UISystem em métodos específicos (ex.: showPauseOverlay, renderSettingsPanel).

Conectar inputs a SettingsSystem via eventos (settings-changed).

Documentar integração no agents.md.

Checklist: fluxos de pausa, ajustes de volume e remapeamento básico.

Dependências: Etapa 2 (botão de configurações acessível), Etapa 0 (checklist atualizado).

Etapa 4 – Upgrades e tela de level-up
Objetivo: oferecer escolhas ricas e escaláveis.

Tarefas:

Criar src/data/upgrades.js:

Estrutura com níveis, categorias, pré-requisitos, ícones e descrições longas.

Separar texto para tradução futura, se desejado.

Atualizar ProgressionSystem:

Consumir o novo arquivo, suportar múltiplos níveis por upgrade e efeitos específicos.

Emitir eventos ricos (upgrade-options-ready, upgrade-applied) com metadados completos.

Refatorar UISystem.showLevelUpScreen:

Construir cards dinamicamente (grid responsivo, badges de nível, descrições).

Suportar navegação por teclado/gamepad (reutilizar bindings do InputSystem).

Checklist: cenários de escolha com teclado, mouse, gamepad; cobertura para upgrades esgotados.

Dependências: Etapa 3 (para input/configurações), Etapa 1 (HUD coeso exibindo upgrades ativos).

Etapa 5 – Acessibilidade e responsividade
Objetivo: ampliar alcance e conforto visual.

Tarefas:

Criar variantes de design tokens em style.css:

Modo daltônico, maior contraste, redução de motion.

Utilizar atributos data-theme ou classes definidas pelo SettingsSystem.

Revisar layout (HTML/CSS):

Usar unidades relativas (rem, clamp) e media queries.

Garantir legibilidade mínima (WCAG AA de contraste).

Integrar opções no SettingsSystem:

Toggles (ex.: “Modo alto contraste”, “Reduzir partículas”).

Propagar mudanças via eventos (settings-visual-changed).

Checklist: resoluções diversas (mobile landscape, 1366×768, 1920×1080) e verificação de contraste.

Dependências: Etapa 3 (Settings) e tokens prontos (já existentes em style.css).

Etapa 6 – Histórico e estatísticas de partidas
Objetivo: dar feedback pós-partida e incentivar progressão.

Tarefas:

Criar HistorySystem (src/modules/HistorySystem.js):

Armazenar dados recebidos via player-died (kills, tempo, ondas, upgrades).

Persistir no localStorage, manter janela (ex.: últimas 10 partidas) e expor agregados.

Estender UISystem:

Mostrar estatísticas no game over (médias, melhor run, variação).

Considerar gráficos simples (SVG inline ou canvas leve) sem bibliotecas externas.

Documentar formato dos dados (/docs/history.md ou seção no checklist).

Checklist: validação de persistência, limpeza, cenários sem histórico.

Dependências: Etapa 3 (Settings para possíveis resets), Etapa 4 (dados de upgrades).

Etapa 7 – Efeitos visuais e performance
Objetivo: aprimorar imersão com controle de intensidade.

Tarefas:

Refatorar EffectsSystem:

Introduzir src/data/particles.js (configurações por tipo: thruster, shield, XP, explosões).

Permitir ajuste de intensidade (SettingsSystem → eventos).

Atualizar RenderingSystem ou adicionar módulo dedicado:

Suporte a fundos dinâmicos (paralaxe, animações CSS/Canvas) configuráveis.

Garantir desativação via opção “modo performance”.

Medir impacto (60 FPS mínimo) e ajustar checklist com cenários de performance.

Avaliar integração com AudioSystem/SettingsSystem para sincronizar feedback (ex.: vibração visual menor quando volumes baixos).

Dependências: Etapa 3 (Settings) e Etapa 5 (opções de acessibilidade/performance).

