<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Visual Enemy Rendering Harness</title>
    <style>
      :root {
        color-scheme: dark;
        font-family: 'Inter', 'Segoe UI', Roboto, sans-serif;
        background-color: #05070b;
      }

      body {
        margin: 0;
        padding: 24px;
        background: radial-gradient(circle at top, #111826 0%, #05070b 65%);
        color: #d8e2ff;
        display: flex;
        flex-direction: column;
        gap: 24px;
        min-height: 100vh;
      }

      header {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      header h1 {
        margin: 0;
        font-size: 28px;
        letter-spacing: 0.04em;
      }

      header p {
        margin: 0;
        color: #9fb6d4;
      }

      .layout {
        display: grid;
        grid-template-columns: 320px 1fr;
        gap: 24px;
        align-items: start;
      }

      .control-panel {
        background: linear-gradient(180deg, rgba(24, 32, 48, 0.88), rgba(8, 12, 20, 0.92));
        border: 1px solid rgba(96, 124, 168, 0.35);
        border-radius: 16px;
        padding: 20px;
        display: flex;
        flex-direction: column;
        gap: 20px;
        box-shadow: 0 12px 32px rgba(4, 8, 16, 0.45);
      }

      .control-panel h2 {
        margin: 0;
        font-size: 20px;
        color: #f6f8ff;
      }

      .control-group {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .control-group label {
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-weight: 600;
        color: #c6d4f4;
      }

      .control-group input[type='range'] {
        width: 100%;
      }

      .control-group button {
        padding: 10px 14px;
        border-radius: 10px;
        border: none;
        background: linear-gradient(135deg, #314b7a, #4769b0);
        color: #f6f8ff;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.12s ease, box-shadow 0.12s ease;
      }

      .control-group button:hover {
        transform: translateY(-1px);
        box-shadow: 0 6px 14px rgba(44, 94, 166, 0.45);
      }

      .toggle {
        display: flex;
        align-items: center;
        gap: 10px;
        font-weight: 600;
        color: #c6d4f4;
      }

      canvas {
        width: 100%;
        max-width: 1200px;
        height: auto;
        border-radius: 18px;
        border: 1px solid rgba(90, 118, 160, 0.35);
        background: #0a0e14;
        box-shadow: 0 18px 44px rgba(2, 6, 12, 0.75);
      }

      .metrics {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
        gap: 12px;
        font-family: 'JetBrains Mono', 'Fira Code', monospace;
        font-size: 14px;
        background: rgba(12, 18, 30, 0.85);
        border: 1px solid rgba(86, 112, 158, 0.4);
        border-radius: 14px;
        padding: 16px;
      }

      .metrics strong {
        color: #eef3ff;
        display: block;
        font-size: 12px;
        letter-spacing: 0.04em;
        text-transform: uppercase;
        margin-bottom: 4px;
      }

      .metrics .section-title {
        grid-column: 1 / -1;
        margin-top: 8px;
        font-size: 13px;
        color: #7ea6ff;
        text-transform: uppercase;
        letter-spacing: 0.08em;
      }

      footer {
        color: #5f7598;
        font-size: 13px;
        line-height: 1.5;
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Visual Enemy Rendering Harness</h1>
      <p>
        Valide manualmente as animações e materiais dos inimigos antes de ativar o
        WaveManager. Ajuste os controles, observe o FPS e preencha a checklist em
        <code>docs/validation/enemy-rendering-visual-checklist.md</code>.
      </p>
    </header>

    <div class="layout">
      <aside class="control-panel">
        <h2>Controles</h2>

        <div class="control-group">
          <label for="drone-speed">
            Drone Speed
            <span id="drone-speed-value">75%</span>
          </label>
          <input id="drone-speed" type="range" min="0" max="100" value="75" />
        </div>

        <div class="control-group">
          <label for="hunter-turret-speed">
            Hunter Turret Speed
            <span id="hunter-speed-value">90°/s</span>
          </label>
          <input
            id="hunter-turret-speed"
            type="range"
            min="10"
            max="240"
            step="5"
            value="90"
          />
        </div>

        <div class="control-group">
          <button id="toggle-mine-armed" type="button">Toggle Armed</button>
          <label class="toggle">
            <input id="show-bounds" type="checkbox" /> Show Bounding Circles
          </label>
        </div>

        <div id="metrics" class="metrics"></div>
      </aside>

      <main>
        <canvas
          id="enemy-canvas"
          width="1200"
          height="800"
          aria-label="Visualização de renderização de inimigos"
        ></canvas>
      </main>
    </div>

    <footer>
      Use os sliders para testar aceleração do Drone e rotação independente do
      Hunter. O botão alterna o estado da Mine. Ative os bounding circles para
      confirmar preservação do estado do canvas após cada draw.
    </footer>

    <script type="module">
      import { Drone } from '../src/modules/enemies/types/Drone.js';
      import { Mine } from '../src/modules/enemies/types/Mine.js';
      import { Hunter } from '../src/modules/enemies/types/Hunter.js';
      import {
        ENEMY_EFFECT_COLORS,
        ENEMY_RENDER_PRESETS,
        ENEMY_TYPES,
      } from '../src/core/GameConstants.js';
      import RandomService from '../src/core/RandomService.js';

      const canvas = document.getElementById('enemy-canvas');
      const ctx = canvas.getContext('2d');

      const droneSpeedSlider = document.getElementById('drone-speed');
      const droneSpeedValue = document.getElementById('drone-speed-value');
      const hunterSpeedSlider = document.getElementById('hunter-turret-speed');
      const hunterSpeedValue = document.getElementById('hunter-speed-value');
      const toggleMineArmed = document.getElementById('toggle-mine-armed');
      const showBoundsCheckbox = document.getElementById('show-bounds');
      const metricsEl = document.getElementById('metrics');

      const harnessRandom = new RandomService('enemy-visual-harness');
      const droneRandom = harnessRandom.fork('drone');
      const mineRandom = harnessRandom.fork('mine');
      const hunterRandom = harnessRandom.fork('hunter');

      const baseDroneRadius = ENEMY_TYPES?.drone?.radius ?? 18;
      const baseMineRadius = ENEMY_TYPES?.mine?.radius ?? 18;
      const baseHunterRadius = ENEMY_TYPES?.hunter?.radius ?? 22;

      const drone = new Drone(null, {
        id: 'visual-drone',
        radius: baseDroneRadius * 1.6,
        random: droneRandom,
      });
      const mine = new Mine(null, {
        id: 'visual-mine',
        radius: baseMineRadius * 1.3,
        random: mineRandom,
      });
      const hunter = new Hunter(null, {
        id: 'visual-hunter',
        radius: baseHunterRadius * 1.4,
        random: hunterRandom,
      });

      const areaWidth = canvas.width / 3;
      drone.x = areaWidth * 0.5;
      mine.x = areaWidth * 1.5;
      hunter.x = areaWidth * 2.5;
      drone.y = mine.y = hunter.y = canvas.height * 0.52;

      drone.rotation = -Math.PI / 2;
      mine.rotation = 0;
      hunter.rotation = -Math.PI / 2;
      hunter.turretAngle = hunter.rotation;

      let droneSpeedControl = Number(droneSpeedSlider.value) / 100;
      let hunterTurretSpeed = Number(hunterSpeedSlider.value) * (Math.PI / 180);
      let showBounding = false;
      let autoMineToggleTimer = 0;
      let droneRotationDrift = 0;

      const exhaustPreset = ENEMY_RENDER_PRESETS?.drone?.exhaust ?? {};
      const droneMaxSpeed = Math.max(1, drone.maxSpeed || ENEMY_TYPES?.drone?.speed || 180);

      droneSpeedSlider.addEventListener('input', (event) => {
        droneSpeedControl = Number(event.target.value) / 100;
        droneSpeedValue.textContent = `${event.target.value}%`;
      });

      hunterSpeedSlider.addEventListener('input', (event) => {
        const degreesPerSecond = Number(event.target.value);
        hunterTurretSpeed = degreesPerSecond * (Math.PI / 180);
        hunterSpeedValue.textContent = `${degreesPerSecond}°/s`;
      });

      toggleMineArmed.addEventListener('click', () => {
        mine.armed = !mine.armed;
        autoMineToggleTimer = 0;
        toggleMineArmed.textContent = mine.armed ? 'Disarm Mine' : 'Arm Mine';
      });

      showBoundsCheckbox.addEventListener('change', (event) => {
        showBounding = event.target.checked;
      });

      const droneCycle = {
        time: 0,
        phase: 0,
      };

      let lastTimestamp = performance.now();
      let fps = 0;
      let frameTimeMs = 0;
      const fpsSmoothing = 0.12;

      function wrapAngle(angle) {
        if (!Number.isFinite(angle)) {
          return 0;
        }
        let normalized = angle % (Math.PI * 2);
        if (normalized <= -Math.PI) {
          normalized += Math.PI * 2;
        } else if (normalized > Math.PI) {
          normalized -= Math.PI * 2;
        }
        return normalized;
      }

      function formatPercent(value) {
        return `${Math.round(value * 100)}%`;
      }

      function renderFrame(timestamp) {
        const deltaTime = Math.max(0.0001, (timestamp - lastTimestamp) / 1000);
        lastTimestamp = timestamp;
        frameTimeMs = deltaTime * 1000;

        const instantFps = 1 / deltaTime;
        fps = fps ? fps + (instantFps - fps) * fpsSmoothing : instantFps;

        droneCycle.time += deltaTime;
        droneCycle.phase = (Math.sin(droneCycle.time * 0.85) + 1) * 0.5;
        droneRotationDrift += deltaTime * 0.25;

        const thrustBlend = droneSpeedControl * droneCycle.phase;
        const rotationOffset = Math.sin(droneRotationDrift) * 0.2;
        drone.rotation = wrapAngle(-Math.PI / 2 + rotationOffset);
        const targetSpeed = thrustBlend * droneMaxSpeed;
        drone.vx = Math.cos(drone.rotation) * targetSpeed;
        drone.vy = Math.sin(drone.rotation) * targetSpeed;

        mine.pulsePhase = (mine.pulsePhase + mine.pulseSpeed * deltaTime) % (Math.PI * 2);
        autoMineToggleTimer += deltaTime;
        if (autoMineToggleTimer >= 3) {
          mine.armed = !mine.armed;
          autoMineToggleTimer = 0;
          toggleMineArmed.textContent = mine.armed ? 'Disarm Mine' : 'Arm Mine';
        }

        hunter.rotation = wrapAngle(hunter.rotation + deltaTime * 0.35);
        hunter.turretAngle = wrapAngle(hunter.turretAngle + hunterTurretSpeed * deltaTime);

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#0a0e14';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.save();
        ctx.strokeStyle = 'rgba(42, 58, 92, 0.5)';
        ctx.lineWidth = 1;
        for (let i = 1; i < 3; i += 1) {
          const x = areaWidth * i;
          ctx.beginPath();
          ctx.moveTo(x, 56);
          ctx.lineTo(x, canvas.height - 32);
          ctx.stroke();
        }
        ctx.restore();

        const labels = [
          { title: 'Drone', subtitle: 'Thruster Response' },
          { title: 'Mine', subtitle: 'Pulse & Halo' },
          { title: 'Hunter', subtitle: 'Turret Tracking' },
        ];

        ctx.save();
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.font = '600 24px "Inter", sans-serif';
        labels.forEach((label, index) => {
          const centerX = areaWidth * (index + 0.5);
          ctx.fillStyle = '#dae6ff';
          ctx.fillText(label.title, centerX, 36);
          ctx.font = '500 15px "Inter", sans-serif';
          ctx.fillStyle = '#7ea6ff';
          ctx.fillText(label.subtitle, centerX, 64);
          ctx.font = '600 24px "Inter", sans-serif';
        });
        ctx.restore();

        let renderCalls = 0;
        const dronePayload = drone.onDraw(ctx);
        renderCalls += 1;
        const minePayload = mine.onDraw(ctx);
        renderCalls += 1;
        const hunterPayload = hunter.onDraw(ctx);
        renderCalls += 1;

        if (showBounding) {
          ctx.save();
          ctx.strokeStyle = 'rgba(126, 166, 255, 0.8)';
          ctx.lineWidth = 1.5;
          ctx.setLineDash([6, 6]);
          ctx.beginPath();
          ctx.arc(drone.x, drone.y, dronePayload.radius, 0, Math.PI * 2);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(mine.x, mine.y, minePayload.radius, 0, Math.PI * 2);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(hunter.x, hunter.y, hunterPayload.radius, 0, Math.PI * 2);
          ctx.stroke();
          ctx.restore();
          renderCalls += 3;
        }

        ctx.save();
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        ctx.font = '500 15px "JetBrains Mono", monospace';
        ctx.fillStyle = '#9fb6d4';
        ctx.fillText(
          `Thrust: ${dronePayload.thrust?.toFixed(2) ?? '0.00'} | Speed: ${formatPercent(
            Math.min(1, Math.hypot(drone.vx, drone.vy) / droneMaxSpeed),
          )}`,
          drone.x - areaWidth * 0.45,
          drone.y + dronePayload.radius + 24,
        );
        ctx.fillText(
          `Pulse: ${minePayload.pulse?.toFixed(2) ?? '0.00'} | Armed: ${minePayload.armed ? 'Yes' : 'No'}`,
          mine.x - areaWidth * 0.45,
          mine.y + minePayload.radius + 24,
        );
        ctx.fillText(
          `Hull: ${(wrapAngle(hunter.rotation) * (180 / Math.PI)).toFixed(1)}° | Turret: ${(wrapAngle(
            hunter.turretAngle,
          ) * (180 / Math.PI)).toFixed(1)}°`,
          hunter.x - areaWidth * 0.45,
          hunter.y + hunterPayload.radius + 24,
        );
        ctx.restore();

        metricsEl.innerHTML = `
          <div>
            <strong>FPS</strong>
            ${fps.toFixed(1)}
          </div>
          <div>
            <strong>Frame Time</strong>
            ${frameTimeMs.toFixed(2)} ms
          </div>
          <div>
            <strong>Render Calls</strong>
            ${renderCalls}
          </div>
          <div class="section-title">Drone</div>
          <div>
            <strong>Thrust</strong>
            ${dronePayload.thrust?.toFixed(2) ?? '0.00'}
          </div>
          <div>
            <strong>Speed</strong>
            ${formatPercent(Math.min(1, Math.hypot(drone.vx, drone.vy) / droneMaxSpeed))}
          </div>
          <div>
            <strong>Glow Blur</strong>
            ${((exhaustPreset.blurBase ?? 6) + (exhaustPreset.blurRange ?? 0) * (dronePayload.thrust ?? 0)).toFixed(1)}
          </div>
          <div class="section-title">Mine</div>
          <div>
            <strong>Pulse</strong>
            ${minePayload.pulse?.toFixed(2) ?? '0.00'}
          </div>
          <div>
            <strong>State</strong>
            ${minePayload.armed ? 'Armed' : 'Unarmed'}
          </div>
          <div>
            <strong>Halo Color</strong>
            ${ENEMY_EFFECT_COLORS?.mine?.halo ?? '#ffc480'}
          </div>
          <div class="section-title">Hunter</div>
          <div>
            <strong>Hull Angle</strong>
            ${(wrapAngle(hunter.rotation) * (180 / Math.PI)).toFixed(1)}°
          </div>
          <div>
            <strong>Turret Angle</strong>
            ${(wrapAngle(hunter.turretAngle) * (180 / Math.PI)).toFixed(1)}°
          </div>
          <div>
            <strong>Turret Speed</strong>
            ${hunterSpeedValue.textContent}
          </div>
        `;

        requestAnimationFrame(renderFrame);
      }

      requestAnimationFrame(renderFrame);
    </script>
  </body>
</html>
